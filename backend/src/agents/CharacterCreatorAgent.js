const geminiService = require('../utils/gemini');
const Character = require('../models/Character');
const Story = require('../models/Story');
const { createResponse, createErrorResponse } = require('../utils/helpers');

class CharacterCreatorAgent {
  constructor() {
    this.name = 'Character Creator Agent';
    this.version = '1.0.0';
  }

  /**
   * Create characters and setting for a story
   * @param {string} storyId - Story ID
   * @param {Object} storyData - Story data including premise and genre
   * @returns {Object} Agent response
   */
  async createCharactersAndSetting(storyId, storyData) {
    try {
      console.log(`ü§ñ ${this.name} starting work on story: ${storyId}`);

      // Update story status
      await Story.findByIdAndUpdate(storyId, {
        'agentProgress.agent1.status': 'in-progress',
        'agentProgress.agent1.notes': 'Creating characters and setting...'
      });

      const { premise, genre, userId } = storyData;

      // Generate characters using Gemini
      console.log('üìù Generating characters...');
      const charactersData = await geminiService.generateCharacters(premise, genre, 4);
      console.log('üìù Generated characters data:', JSON.stringify(charactersData, null, 2));
      
      // Check if characters were generated
      if (!charactersData || !Array.isArray(charactersData) || charactersData.length === 0) {
        console.error('‚ùå No characters generated by Gemini');
        throw new Error('Failed to generate characters');
      }

      // Generate setting using Gemini
      console.log('üåç Generating setting...');
      const settingData = await geminiService.generateSetting(premise, genre);

      // Create character documents
      const createdCharacters = [];
      console.log(`üìù Creating ${charactersData.length} characters...`);
      for (const charData of charactersData) {
        console.log(`üìù Creating character: ${charData.name}`);
        try {
          // Map relationships to the correct format
          const relationships = (charData.relationships || []).map(rel => ({
            characterId: null, // Will be set later when we have character IDs
            relationshipType: rel.relationshipType || 'neutral',
            description: rel.description || ''
          }));

          const character = new Character({
            name: charData.name,
            description: `${charData.physicalDescription || ''}. ${charData.personality || ''}`.trim(),
            personality: charData.personality || '',
            background: charData.background || '',
            role: charData.role || 'supporting',
            appearance: {
              age: charData.age || 25,
              gender: charData.gender || 'unknown',
              physicalDescription: charData.physicalDescription || '',
              clothing: charData.clothing || 'Not specified'
            },
            motivations: charData.motivations || [],
            relationships: relationships,
            storyId,
            createdBy: 'agent1'
          });

          const savedCharacter = await character.save();
          createdCharacters.push(savedCharacter);
          console.log(`‚úÖ Created character: ${savedCharacter.name}`);
        } catch (charError) {
          console.error(`‚ùå Error creating character ${charData.name}:`, charError.message);
          console.error('Character data:', charData);
          console.error('Full error:', charError);
          
          // If it's a validation error, try to fix it
          if (charError.name === 'ValidationError') {
            console.log('üîß Attempting to fix validation errors...');
            // Fix relationship types that might be invalid
            if (charData.relationships) {
              charData.relationships = charData.relationships.map(rel => ({
                ...rel,
                relationshipType: ['friend', 'enemy', 'family', 'romantic', 'mentor', 'rival', 'neutral', 'adversary', 'adversarial', 'colleague', 'acquaintance'].includes(rel.relationshipType) 
                  ? rel.relationshipType 
                  : 'neutral'
              }));
            }
            
            // Try again with fixed data
            try {
              const character = new Character({
                name: charData.name,
                description: `${charData.physicalDescription || ''}. ${charData.personality || ''}`.trim(),
                personality: charData.personality || '',
                background: charData.background || '',
                role: charData.role || 'supporting',
                appearance: {
                  age: charData.age || 25,
                  gender: charData.gender || 'unknown',
                  physicalDescription: charData.physicalDescription || '',
                  clothing: charData.clothing || 'Not specified'
                },
                motivations: charData.motivations || [],
                relationships: (charData.relationships || []).map(rel => ({
                  characterId: null,
                  relationshipType: rel.relationshipType || 'neutral',
                  description: rel.description || ''
                })),
                storyId,
                createdBy: 'agent1'
              });

              const savedCharacter = await character.save();
              createdCharacters.push(savedCharacter);
              console.log(`‚úÖ Created character (retry): ${savedCharacter.name}`);
            } catch (retryError) {
              console.error(`‚ùå Failed to create character even after retry: ${charData.name}`, retryError.message);
            }
          }
        }
      }

      // Update story with setting and characters
      const story = await Story.findById(storyId);
      if (story) {
        story.setting = {
          time: settingData.time,
          place: settingData.place,
          atmosphere: settingData.atmosphere,
          worldRules: settingData.worldRules || []
        };
        
        story.characters = createdCharacters.map(char => char._id);
        story.tags = [genre, 'ai-generated'];
        story.agentProgress.agent1.status = 'completed';
        story.agentProgress.agent1.completedAt = new Date();
        story.agentProgress.agent1.notes = `Created ${createdCharacters.length} characters and setting`;
        
        await story.save();
        console.log('‚úÖ Story updated with characters and setting');
        console.log(`üìù Final character count: ${createdCharacters.length}`);
      }

      return createResponse(true, {
        characters: createdCharacters,
        setting: settingData,
        message: `Successfully created ${createdCharacters.length} characters and setting`
      }, 'Character creation completed successfully');

    } catch (error) {
      console.error(`‚ùå ${this.name} error:`, error.message);
      
      // Update story with error status
      await Story.findByIdAndUpdate(storyId, {
        'agentProgress.agent1.status': 'failed',
        'agentProgress.agent1.notes': `Error: ${error.message}`
      });

      return createErrorResponse(
        `Character creation failed: ${error.message}`,
        500,
        { agent: this.name, storyId }
      );
    }
  }

  /**
   * Add a new character to an existing story
   * @param {string} storyId - Story ID
   * @param {Object} characterData - Character data
   * @returns {Object} Agent response
   */
  async addCharacter(storyId, characterData) {
    try {
      const story = await Story.findById(storyId);
      if (!story) {
        return createErrorResponse('Story not found', 404);
      }

      const character = new Character({
        ...characterData,
        storyId,
        createdBy: 'agent1'
      });

      const savedCharacter = await character.save();
      
      // Add character to story
      await story.addCharacter(savedCharacter._id);

      return createResponse(true, savedCharacter, 'Character added successfully');

    } catch (error) {
      console.error(`‚ùå ${this.name} add character error:`, error.message);
      return createErrorResponse(`Failed to add character: ${error.message}`, 500);
    }
  }

  /**
   * Update character relationships
   * @param {string} storyId - Story ID
   * @returns {Object} Agent response
   */
  async updateCharacterRelationships(storyId) {
    try {
      const characters = await Character.findByStory(storyId);
      
      // Generate relationship updates using Gemini
      const relationshipPrompt = `
      Analyze these characters and suggest relationship improvements:
      ${characters.map(char => 
        `${char.name} (${char.role}): ${char.description}`
      ).join('\n')}
      
      Suggest 2-3 key relationships that would enhance the story.
      `;

      const relationshipSuggestions = await geminiService.generateText(relationshipPrompt);
      
      return createResponse(true, {
        suggestions: relationshipSuggestions,
        characters: characters.length
      }, 'Relationship analysis completed');

    } catch (error) {
      console.error(`‚ùå ${this.name} relationship update error:`, error.message);
      return createErrorResponse(`Failed to update relationships: ${error.message}`, 500);
    }
  }

  /**
   * Get agent status and capabilities
   * @returns {Object} Agent information
   */
  getAgentInfo() {
    return {
      name: this.name,
      version: this.version,
      capabilities: [
        'Create compelling characters',
        'Develop immersive settings',
        'Establish character relationships',
        'Generate character backgrounds',
        'Define character motivations'
      ],
      status: 'active'
    };
  }

  /**
   * Health check for the agent
   * @returns {Object} Health status
   */
  async healthCheck() {
    try {
      const geminiHealth = await geminiService.healthCheck();
      
      return {
        agent: this.name,
        status: geminiHealth.status === 'healthy' ? 'healthy' : 'unhealthy',
        dependencies: {
          gemini: geminiHealth
        },
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      return {
        agent: this.name,
        status: 'unhealthy',
        error: error.message,
        timestamp: new Date().toISOString()
      };
    }
  }
}

module.exports = CharacterCreatorAgent;
